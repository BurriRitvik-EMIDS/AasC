import os
import re
import subprocess
import sys

PROJECT_ROOT = r"D:\AgentAsCode_BE\agent_clinic"


def create_and_setup_venv(project_path):
    """
    Create a virtual environment and install requirements for the project.
    """
    try:
        venv_path = os.path.join(project_path, "venv")

        # Check if venv already exists
        if os.path.exists(venv_path):
            print(f"[INFO] Virtual environment already exists at {venv_path}")
            return True

        print(f"[INFO] Creating virtual environment at {venv_path}")

        # Create virtual environment
        result = subprocess.run([
            sys.executable, "-m", "venv", venv_path
        ], capture_output=True, text=True, cwd=project_path)

        if result.returncode != 0:
            print(
                f"[ERROR] Failed to create virtual environment: {result.stderr}")
            return False

        print("[INFO] Virtual environment created successfully")

        # Determine the correct pip path based on OS
        if os.name == 'nt':  # Windows
            pip_path = os.path.join(venv_path, "Scripts", "pip.exe")
            python_path = os.path.join(venv_path, "Scripts", "python.exe")
        else:  # Unix/Linux/Mac
            pip_path = os.path.join(venv_path, "bin", "pip")
            python_path = os.path.join(venv_path, "bin", "python")

        # Upgrade pip first
        print("[INFO] Upgrading pip...")
        upgrade_result = subprocess.run([
            python_path, "-m", "pip", "install", "--upgrade", "pip"
        ], capture_output=True, text=True, cwd=project_path)

        if upgrade_result.returncode != 0:
            print(f"[WARNING] Failed to upgrade pip: {upgrade_result.stderr}")

        # Install requirements
        requirements_file = os.path.join(project_path, "requirements.txt")
        if os.path.exists(requirements_file):
            print(f"[INFO] Installing requirements from {requirements_file}")
            install_result = subprocess.run([
                python_path, "-m", "pip", "install", "-r", "requirements.txt"
            ], capture_output=True, text=True, cwd=project_path)

            if install_result.returncode != 0:
                print(
                    f"[ERROR] Failed to install requirements: {install_result.stderr}")
                return False
            else:
                print("[INFO] Requirements installed successfully")
        else:
            print("[WARNING] No requirements.txt found, skipping package installation")

        return True

    except Exception as e:
        print(
            f"[ERROR] Exception while setting up virtual environment: {str(e)}")
        return False


def create_startup_scripts(project_path):
    """
    Create startup scripts for different operating systems.
    """
    try:
        # Windows batch script
        windows_script = """@echo off
echo Starting project with virtual environment...
cd /d "%~dp0"
call venv\\Scripts\\activate.bat
python main.py
pause
"""
        safe_write(f"{project_path}/start_project.bat", windows_script)

        # Unix/Linux shell script
        unix_script = """#!/bin/bash
echo "Starting project with virtual environment..."
cd "$(dirname "$0")"
source venv/bin/activate
python main.py
"""
        safe_write(f"{project_path}/start_project.sh", unix_script)

        # Make shell script executable on Unix systems
        if os.name != 'nt':
            os.chmod(f"{project_path}/start_project.sh", 0o755)

        print("[INFO] Startup scripts created successfully")
        return True

    except Exception as e:
        print(f"[ERROR] Failed to create startup scripts: {str(e)}")
        return False


def create_project_readme(project_path, project_data):
    """
    Create a README file with instructions for the project.
    """
    try:
        project_name = getattr(
            project_data, 'project_name', 'AI Agent Project')
        port = getattr(project_data, 'port_number', '4304')

        readme_content = f"""# {project_name}

This is an AI Agent project generated by AgentAsCode.

## Quick Start

### Option 1: Using Startup Scripts (Recommended)
- **Windows**: Double-click `start_project.bat`
- **Linux/Mac**: Run `./start_project.sh`

### Option 2: Manual Setup
1. Activate the virtual environment:
   - **Windows**: `venv\\Scripts\\activate`
   - **Linux/Mac**: `source venv/bin/activate`

2. Run the project:
   ```bash
   python main.py
   ```

## Project Structure
- `main.py` - Main FastAPI application
- `config.py` - Project configuration
- `.env` - Environment variables
- `requirements.txt` - Python dependencies
- `venv/` - Virtual environment (auto-created)
- `Supervisor/` - Supervisor agent and sub-agents

## API Endpoints
- **Chat Interface**: `POST /query` - Send messages to the AI agent
- **Health Check**: The project runs on port {port}

## Environment Variables
Make sure to set your API keys in the `.env` file:
- `GOOGLE_API_KEY` - Your Google API key for Gemini

## Troubleshooting
If you encounter issues:
1. Make sure the virtual environment is activated
2. Check that all dependencies are installed: `pip install -r requirements.txt`
3. Verify your API keys are set correctly in `.env`

## Support
For issues or questions, check the project documentation or contact support.
"""

        safe_write(f"{project_path}/README.md", readme_content)
        print("[INFO] README.md created successfully")
        return True

    except Exception as e:
        print(f"[ERROR] Failed to create README: {str(e)}")
        return False


# -------- Templates --------
FINAL_EVAL_CRITERIA = (
    "You are an evaluator tasked with assessing a final response from an assistant, using the following strict criteria. "
    "Below is the conversation context and the assistant's final response. "
    "Assign scores between 0 and 100 for each metric. Be consistent and rigorous.\n\n"
    "### VERY IMPORTANT HALLUCINATION INSTRUCTION:\n"
    "You MUST only consider statements that are clearly supported by the context below.\n"
    "- If the response includes any reasons, explanations, or claims that are not explicitly found in the context, and are not basic commonsense (e.g., 'the sky is blue'), then mark them as hallucinations.\n"
    "- Hypothetical suggestions ('It could be...', 'Perhaps...') that are not grounded in the context must also be penalized for hallucination.\n\n"
    "### Scoring Criteria:\n"
    "1. **Hallucination**: Rate the factual accuracy. A score of 0 means no hallucination and everything is verifiable from the context not from the general knowledge. "
    "If the response comes from the general knowledge, then it is considered hallucination. "
    "A score of 100 means the response contains entirely fabricated or incorrect information. Use 10–30 for minor factual errors, 40–70 for partial inaccuracies, and 80+ for significant hallucinations.\n"
    "2. **Coherence**: Does the response logically flow and make sense in the context? 0 = completely disjointed, 100 = seamless and logically sound.\n"
    "3. **Relevance**: Is the response on-topic and directly related to the user's question or the prior messages? 0 = off-topic, 100 = directly addresses the core query.\n"
    "4. **Clarity**: Is the response easy to understand? 0 = unclear or confusing, 100 = crystal clear and readable.\n"
    "5. **Conciseness**: Is the response free of unnecessary information? 0 = very wordy or redundant, 100 = tight and efficient.\n\n"
    "6. **Specificity**: Does the response avoid vague or generic phrasing and instead provide precise, concrete details that align with the user's query? "
    "0 = vague, generic, or overly broad; 100 = highly detailed and specific with minimal ambiguity.\n\n"
    "Return ONLY a valid JSON object in this format:\n"
    # '{{"hallucination": <score>, "coherence": <score>, "relevance": <score>, "clarity": <score>, "conciseness": <score>, "specificity": <score>}}\n\n'
    # "### Conversation Context:\n"
    # "{context_str}"
    # "\n\n### Final Response:\n"
    # "{final_text}"
    "\n### JSON Output:"
)


# Agent template for Google ADK
AGENT_TEMPLATE = '''import os
from google.adk.agents import Agent
from typing import Dict, Any

# Import tools
from google.adk.tools.mcp_tool import MCPToolset, StdioConnectionParams, StreamableHTTPConnectionParams
# {imports}

def create_agent() -> Agent:
    """Create and configure the {agent_name} agent."""
    return Agent(
        name="{agent_name}",
        model="{model}",
        description="""{description}""",
        instruction="""{instruction}""",
        tools=[MCPToolset(
        connection_params=StreamableHTTPConnectionParams(
            url="http://localhost:8001/mcp/"
        )
    )]
    )

# Create the agent instance
{agent_name}_agent = create_agent()
'''

# # Tool template for Google ADK
# TOOL_TEMPLATE = '''def {function_name}({parameters}) -> {return_type}:
#     """{description}

#     Args:
# {param_docs}

#     Returns:
#         {return_type}: {return_description}
#     """
#     try:
#         # Tool implementation goes here
#         {implementation}
#     except Exception as e:
#         return {{"status": "error", "message": str(e)}}
# '''
# Supervisor template for Google ADK
SUPERVISOR_TEMPLATE = '''from google.adk.agents import Agent
from typing import Dict, Any, List, Optional

# Import subagents
{imports}

class SupervisorAgent:
    def __init__(self, model: str = "gemini-2.0-flash"):
        self.agent = Agent(
            name="supervisor_agent",
            model=model,
            description="Coordinates between specialized subagents",
            instruction="{instruction}"
        )
        self.subagents = {{
            {subagent_mapping}
        }}
    
    async def route_query(self, query: str, user_id: str = "default_user") -> Dict[str, Any]:
        """Route a query to the appropriate subagent."""
        # Implementation for routing logic
        pass

# Create supervisor instance
supervisor_agent = SupervisorAgent()
'''


# Environment file template
ENV_FILE = """# Google API Configuration
GOOGLE_API_KEY=your-frontend-api-key
GOOGLE_GENAI_USE_VERTEXAI=FALSE

# Agent Configuration
MODEL_NAME=gemini-2.0-flash
"""

# Root supervisor agent.py using Google ADK
ROOT_AGENT_TEMPLATE = '''from google.adk.agents import Agent

# Import sub-agents
{subagent_import_lines}


# Initialize sub-agents list
sub_agents_list = [{sub_agents}]

root_agent = Agent(
    name="supervisor_agent",
    model="{model}",
    description="Coordinates between specialized subagents",
    instruction="""{instruction}""",
    sub_agents=sub_agents_list
)

# For backward compatibility
supervisor_agent = root_agent
'''

# supervisor __init__ that ensures agent is available
ROOT_INIT_TEMPLATE = "from . import agent\n"

# subagents __init__ that imports individual subagent packages (folders)
SUBAGENTS_INIT_TEMPLATE = "from . import {subagent_list}\n"

# subagent folder __init__ that exposes the agent object
SUBAGENT_INIT_TEMPLATE = "from .agent import {agent}_agent\n"

ADK_TOOL_TEMPLATE = '''from google.adk.tools import tool

@tool
def {tool}({args}):
    """
    {docstring}
    """
    # TODO: Implement actual logic here.
    return "Mock response from {tool}"
'''

ADK_MCP_TOOL_TEMPLATE = '''# MCP tool placeholder for: {tool}
def {tool}(*args, **kwargs):
    return "MCP/SQL tool logic for {tool} is not yet ported to ADK."
'''

PROMPT_TEMPLATE = '''{agent}_instruction = """{prompt}"""'''

ADK_MAIN_TEMPLATE = '''from fastapi import FastAPI, Request, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse, JSONResponse
from pydantic import BaseModel
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from google.genai.types import Content, Part
from dotenv import load_dotenv
import json
import os
import sys
import uuid
import asyncio
import traceback
from fastapi import FastAPI, Request
from pydantic import BaseModel
from {supervisor_name}.agent import root_agent
from google.adk.agents import LlmAgent
from google.genai.types import Content, Part
from fastapi.responses import StreamingResponse, JSONResponse
import asyncio
import json
import base64
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
import os
from fastapi.middleware.cors import CORSMiddleware

# Load environment variables
load_dotenv()

# Add current directory to Python path
current_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, current_dir)

# Initialize FastAPI app with CORS
app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allow all origins
    allow_credentials=True,
    allow_methods=["*"],  # Allow all methods
    allow_headers=["*"],  # Allow all headers
)

session_service = InMemorySessionService()
runner: Runner | None = None


def init_runner():
    global runner
    if runner is not None:
        return runner
    
    agent = root_agent
    runner = Runner(
        app_name="Agent-As-Code",
        agent=agent,
        session_service=session_service,
    )
    return runner


class MessageRequest(BaseModel):
    payload: str


class MemberRequest(BaseModel):
    member_id: str


# Deryption Keys
key = os.getenv('AES_KEY')
iv = os.getenv('AES_IV').encode('utf-8')


def decrypt(enc, key, iv):
    enc = base64.b64decode(enc)
    cipher = AES.new(key.encode('utf-8'), AES.MODE_CBC, iv)
    return unpad(cipher.decrypt(enc), 16)


@app.post("/query")
async def chat(req: MessageRequest):
    init_runner()
    """
    Main query endpoint that processes user messages through the agent.
    """
    decrypted_message = decrypt(req.payload, key, iv).decode('utf-8')
    # data = json.loads(req.payload) if isinstance(
    #     req.payload, str) else req.payload
    data = json.loads(decrypted_message)
    print(data)
    session = await session_service.get_session(
        app_name="Agent-As-Code",
        user_id=data.get("thread_id"),
        session_id=data.get("thread_id")
    )
    if session is None:
        session = await session_service.create_session(
            app_name="Agent-As-Code",
            user_id=data.get("thread_id"),
            session_id=data.get("thread_id")
        )

    # Prepare message
    new_message = Content(role="user", parts=[Part(text=data["message"])])
    # new_message = Content(role="user", parts=[Part(text=decrypted_message)])

    async def event_generator():
        async for event in runner.run_async(
            user_id=data.get("thread_id"),
            session_id=data.get("thread_id"),
            new_message=new_message
        ):
            # Convert event to text-based JSON for streaming
            message = {
                "role": event.author,
                "content": event.content.parts[0].text,
                "image": None,
                "usage_metadata": None,
                "llm_source": "unknown",
                "data_source": "unknown"
            }
            print(message)
            # yield f"data: {json.dumps(message)}\\n"
            yield json.dumps(message) + "\\n"
            await asyncio.sleep(0.01)  # Small delay to allow streaming

    return StreamingResponse(event_generator(), media_type="text/event-stream")


if __name__ == "__main__":
    # Get port from environment variable or use default
    port = int(os.getenv("PORT", {port_number}))

    print(f"[INFO] Starting Agent API on port {port}")
    print(f"[INFO] Root agent loaded: {root_agent is not None}")

    # Run the FastAPI app
    import uvicorn
    init_runner()
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=port,
        reload=True,  # Enable auto-reload in development
        log_level="info"
    )
'''

PROJECT_CONFIG_TEMPLATE = '''from dotenv import load_dotenv
# Google ADK config
load_dotenv()
MODEL_NAME = "{model_name}"
'''

#  .env template with GOOGLE_API_KEY injected
ENVIRONMENT_TEMPLATE = '''# Google AI API Configuration
GOOGLE_API_KEY={api_key}
GOOGLE_GENAI_USE_VERTEXAI=FALSE

AES_KEY = AAAAAAAAAAAAAAAA
AES_IV = BBBBBBBBBBBBBBBB

# If you want Vertex AI instead, set this TRUE and add project/location
# GOOGLE_GENAI_USE_VERTEXAI=TRUE
# GOOGLE_CLOUD_PROJECT=your-project-id
# GOOGLE_CLOUD_LOCATION=us-central1

# Database Configuration (update these values as needed)
# POSTGRES_USER=postgres
# POSTGRES_PASSWORD=yourpassword
# POSTGRES_HOST=localhost
# POSTGRES_PORT=5432
# POSTGRES_DB=agentascode
'''

SQL_MCP_ENV_TEMPLATE = """
mcp_url={mcp_url}
"""

# -------- Helpers --------


def sanitize_filename(filename):
    """
    Remove/replace characters that might break filenames or imports.
    """
    filename = re.sub(r'[:\(\),]', '', filename)
    filename = filename.replace(' ', '_')
    return filename


def safe_write(path, content):
    """
    Ensure directory exists, sanitize file name, then write.
    """
    dir_name, file_name = os.path.split(path)
    file_name = sanitize_filename(file_name)
    safe_path = os.path.join(dir_name, file_name)
    os.makedirs(dir_name, exist_ok=True)
    with open(safe_path, "w", encoding="utf-8") as f:
        f.write(content)


def _format_template_safely(template: str, values: dict) -> str:
    """
    Safely format a template string that includes literal braces by:
    1) Escaping all braces, then
    2) Restoring placeholders for provided keys, and
    3) Applying str.format with the provided values.

    This prevents KeyError from unintended placeholders like {response} found
    inside f-strings or dict literals within the template.
    """
    # Escape all braces
    escaped = template.replace('{', '{{').replace('}', '}}')
    # Restore intended placeholders for provided keys
    for key in values.keys():
        escaped = escaped.replace('{{' + key + '}}', '{' + key + '}')
    return escaped.format(**values)


# -------- Main Functions --------

def create_working_google_adk_module(project_path):
    """
    Create a working google.adk module with real AI functionality.
    """
    import os

    # Create google/adk directory structure
    google_dir = os.path.join(project_path, "google")
    adk_dir = os.path.join(google_dir, "adk")

    os.makedirs(google_dir, exist_ok=True)
    os.makedirs(adk_dir, exist_ok=True)

    # Create google/__init__.py
    safe_write(f"{google_dir}/__init__.py", "")

    # Create google/adk/__init__.py
    safe_write(f"{adk_dir}/__init__.py", "")

    # Create google/adk/agents.py with working LlmAgent
    agents_code = '''import os
import sys
from typing import List, Optional, Any

# Try to import google.generativeai, fallback if not available
try:
    import google.generativeai as genai
    GENAI_AVAILABLE = True
    print(f"[INFO] google.generativeai imported successfully")
except ImportError as e:
    print(f"[WARNING] google.generativeai not available: {e}")
    GENAI_AVAILABLE = False
    genai = None

class LlmAgent:
    """
    A working LLM Agent implementation using Google Generative AI with in-memory session support.
    """
    
    def __init__(self, model: str = "gemini-2.0-flash", name: str = "agent", 
                 sub_agents: Optional[List] = None, description: str = "", 
                 instruction: str = "", session_id: str = None, **kwargs):
        self.model = model
        self.name = name
        self.sub_agents = sub_agents or []
        self.description = description
        self.instruction = instruction
        self.session_id = session_id or str(hash(f"{name}_{id(self)}"))
        
        # In-memory session storage
        self._sessions = {}
        self._init_session()
        
        # Configure Google AI
        api_key = os.getenv("GOOGLE_API_KEY")
        if GENAI_AVAILABLE and api_key:
            try:
                genai.configure(api_key=api_key)
                self.client = genai.GenerativeModel(model_name="gemini-1.5-flash")
                self.use_ai = True
                print(f"[INFO] {self.name} initialized with Google AI")
            except Exception as e:
                print(f"[WARNING] Failed to initialize Google AI for {self.name}: {e}")
                self.use_ai = False
        else:
            if not GENAI_AVAILABLE:
                print(f"[WARNING] google.generativeai not available for {self.name}")
            if not api_key:
                print(f"[WARNING] No GOOGLE_API_KEY found for {self.name}")
            print(f"[INFO] {self.name} using fallback responses")
            self.use_ai = False
    
    def _init_session(self):
        """Initialize a new session if it doesn't exist."""
        if self.session_id not in self._sessions:
            self._sessions[self.session_id] = {
                'history': [],
                'context': {},
                'created_at': time.time(),
                'last_accessed': time.time()
            }
    
    def _update_session(self, **updates):
        """Update session data."""
        if self.session_id in self._sessions:
            self._sessions[self.session_id].update(updates)
            self._sessions[self.session_id]['last_accessed'] = time.time()
    
    def get_session_history(self):
        """Get the conversation history for the current session."""
        self._init_session()
        return self._sessions[self.session_id]['history']
    
    def add_to_history(self, role: str, content: str):
        """Add a message to the session history."""
        self._init_session()
        self._sessions[self.session_id]['history'].append({
            'role': role,
            'content': content,
            'timestamp': time.time()
        })
    
    def run(self, message: str) -> str:
        """
        Process a message and return a response, maintaining conversation context.
        """
        try:
            # Add user message to history
            self.add_to_history('user', message)
            
            # Get conversation history
            history = self.get_session_history()
            
            if self.use_ai and hasattr(self, 'client'):
                # Build context from history
                context = "\n".join(
                    f"{msg['role'].capitalize()}: {msg['content']}" 
                    for msg in history[-5:]  # Use last 5 messages for context
                )
                
                # Create prompt with context
                prompt = f"""You are {self.name}, an AI agent with the following role:
{self.description}

Instructions: {self.instruction}

Previous conversation context:
{context}

User message: {message}

Please provide a helpful and relevant response based on your role, instructions, and conversation context."""
                
                # Generate response
                response = self.client.generate_content(prompt)
                response_text = response.text.strip()
                
                # Add assistant response to history
                self.add_to_history('assistant', response_text)
                
                return f"[{self.name}]: {response_text}"
            
            elif self.sub_agents:
                # Route to subagents if available
                import random
                selected_agent = random.choice(self.sub_agents)
                
                # Add context to the message
                context = " ".join(msg['content'] for msg in history[-3:])  # Last 3 messages as context
                enhanced_message = f"Context: {context}\n\nCurrent message: {message}"
                
                if hasattr(selected_agent, '__call__') or hasattr(selected_agent, 'run'):
                    subagent_response = (selected_agent(enhanced_message) 
                                      if hasattr(selected_agent, '__call__') 
                                      else selected_agent.run(enhanced_message))
                    
                    # Add the interaction to history
                    self.add_to_history('system', f"Routed to {getattr(selected_agent, 'name', 'subagent')}")
                    self.add_to_history('assistant', subagent_response)
                    
                    return f"[{self.name}] → {subagent_response}"
                else:
                    error_msg = f"I'm routing your request about '{message}' to my subagents, but they're not properly configured."
                    self.add_to_history('system', error_msg)
                    return f"[{self.name}]: {error_msg}"
            
            else:
                # Fallback response based on instruction and history
                last_message = history[-2]['content'] if len(history) > 1 else message
                response = f"I understand you're asking about '{last_message}'. Based on my role ({self.description}), I would help you with: {self.instruction[:200]}..."
                self.add_to_history('assistant', response)
                return f"[{self.name}]: {response}"
                
        except Exception as e:
            error_msg = f"I encountered an error processing your message: {str(e)}"
            self.add_to_history('system', f"Error: {str(e)}")
            return f"[{self.name}]: {error_msg}"
    
    def __call__(self, message: str) -> str:
        """
        Make the agent callable directly.
        This is the preferred way to use the agent.
        """
        return self.run(message)
'''

    safe_write(f"{adk_dir}/agents.py", agents_code)

    print(f"[INFO] Created working google.adk module in {project_path}")


def install_google_adk():
    """
    Install google-adk package using pip with force reinstall.
    """
    import subprocess
    import sys

    try:
        print("[INFO] Force installing google-adk package...")
        # Try multiple installation methods
        commands = [
            [sys.executable, "-m", "pip", "install",
                "--force-reinstall", "google-adk"],
            [sys.executable, "-m", "pip", "install", "--upgrade", "google-adk"],
            [sys.executable, "-m", "pip", "install",
                "google-adk", "--no-cache-dir"],
        ]

        for cmd in commands:
            try:
                print(f"[DEBUG] Running: {' '.join(cmd)}")
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=180  # 3 minutes timeout
                )

                if result.returncode == 0:
                    print(
                        f"[INFO] Successfully installed google-adk package with command: {' '.join(cmd)}")
                    return True
                else:
                    print(f"[WARNING] Command failed: {result.stderr}")
                    continue

            except subprocess.TimeoutExpired:
                print(f"[WARNING] Command timed out: {' '.join(cmd)}")
                continue

        print("[ERROR] All installation attempts failed")
        return False

    except Exception as e:
        print(f"[ERROR] Error installing google-adk: {str(e)}")
        return False


def regenerate_project_with_real_adk(project_path, project):
    """
    Regenerate existing project files with real google.adk (no mock).
    """
    from types import SimpleNamespace
    from models import Agent
    from database import get_db

    print(
        f"[DEBUG] Regenerating project files with real google-adk for: {project_path}")

    # Create project data object from database project
    project_data = SimpleNamespace()
    project_data.project_name = project.name
    project_data.project_description = project.description
    project_data.supervisor_prompt = project.supervisor_prompt
    project_data.final_response_prompt = project.final_response_prompt
    project_data.platform = project.platform
    # Contains API key regardless of platform
    project_data.azure_openai_key = project.azure_openai_key
    project_data.azure_openai_url = project.azure_openai_url
    project_data.port_number = project.port_number
    project_data.supervisor_name = "Supervisor"

    print(
        f"[DEBUG] Regenerating for platform: '{project.platform}' (type: {type(project.platform)})")
    print(
        f"[DEBUG] API key present: {'Yes' if project.azure_openai_key else 'No'}")
    print(f"[DEBUG] Using ROOT_AGENT_TEMPLATE with path setup")

    # Get all agents for this project
    db = next(get_db())
    try:
        agents = db.query(Agent).filter(Agent.project_id == project.id).all()

        # Regenerate main.py with correct port and CORS
        supervisor_name = sanitize_filename(
            getattr(project_data, 'supervisor_name', 'Supervisor'))

        # Create a temporary dictionary with all required template variables
        template_vars = {
            'supervisor_name': supervisor_name,
            'port_number': project.port_number,
            'current_dir': "os.path.dirname(os.path.abspath(__file__))"
        }

        # Format the main.py template with all required variables (safe)
        main_code = _format_template_safely(ADK_MAIN_TEMPLATE, template_vars)

        safe_write(f"{project_path}/main.py", main_code)
        print(f"[DEBUG] Regenerated main.py with port {project.port_number}")

        # Also create a config.py file with the port number as backup
        config_content = f"""# Project configuration
PORT = {project.port_number}
"""
        safe_write(f"{project_path}/config.py", config_content)
        print(f"[DEBUG] Created config.py with port {project.port_number}")

        # Regenerate supervisor agent.py (no mock)
        agent_names = [sanitize_filename(agent.name.lower())
                       for agent in agents]
        agent_list = ', '.join([f"{name}_agent" for name in agent_names])

        # Build import lines for root agent file
        all_import_lines = []
        for name in sorted(agent_names):
            import_line = f"from .subagents.{name} import {name}_agent"
            all_import_lines.append(import_line)

        subagent_import_lines = '\n'.join(
            all_import_lines) if all_import_lines else "# No subagents"

        agent_py_path = f"{project_path}/{supervisor_name}/agent.py"

        # Check if agent.py already exists
        if os.path.exists(agent_py_path):
            # Read the existing file
            with open(agent_py_path, 'r') as f:
                existing_content = f.read()

            # Check if the file has been modified from the template
            if 'sub_agents_list = [' in existing_content and 'sub_agents_list = [{' not in existing_content:
                # File has been modified, keep it as is
                print(
                    f"[DEBUG] Preserving existing agent configuration in {agent_py_path}")
            else:
                # File is still using template, update it
                root_agent_code = _format_template_safely(
                    ROOT_AGENT_TEMPLATE,
                    {
                        'subagent_import_lines': subagent_import_lines,
                        'agent_list': agent_list,
                        'model': "gemini-2.0-flash",
                        'instruction': getattr(project_data, 'supervisor_prompt', '')
                    },
                )
                safe_write(agent_py_path, root_agent_code)
        else:
            # Create new agent file with template
            root_agent_code = _format_template_safely(
                ROOT_AGENT_TEMPLATE,
                {
                    'subagent_import_lines': subagent_import_lines,
                    'sub_agents': agent_list,
                    'model': "gemini-2.0-flash",
                    'instruction': getattr(project_data, 'supervisor_prompt', '')
                },
            )
            safe_write(agent_py_path, root_agent_code)

        # Ensure package init files exist
        safe_write(f"{project_path}/{supervisor_name}/__init__.py",
                   ROOT_INIT_TEMPLATE)
        os.makedirs(
            f"{project_path}/{supervisor_name}/subagents", exist_ok=True)
        if agent_names:
            safe_write(f"{project_path}/{supervisor_name}/subagents/__init__.py",
                       SUBAGENTS_INIT_TEMPLATE.format(subagent_list=', '.join(sorted(agent_names))))
        else:
            safe_write(
                f"{project_path}/{supervisor_name}/subagents/__init__.py", "")

        # Regenerate subagent files (no mock)
        for agent in agents:
            agent_name = sanitize_filename(agent.name.lower())
            subagent_base = os.path.join(
                project_path, supervisor_name, "subagents", agent_name)

            # Get final prompt for instruction
            final_prompt_path = os.path.join(
                subagent_base, "prompts", "final_prompt.py")
            try:
                with open(final_prompt_path, "r") as f:
                    instruction = f.read().replace('final_prompt = """', '').replace('"""', '').strip()
            except Exception as e:
                print(
                    f"[WARNING] Could not read final prompt for {agent_name}: {e}")
                instruction = agent.prompt or f"Agent: {agent_name}"

            # Get worker profile for description
            description = getattr(agent, 'worker_profile',
                                  agent.prompt or f"Agent: {agent_name}")

            agent_code = AGENT_TEMPLATE.format(
                agent_name=agent_name,
                model="gemini-2.0-flash",
                description=description,
                instruction=instruction,
                tool_names="",
                imports="",
                tools="[]"
            )
            safe_write(f"{subagent_base}/agent.py", agent_code)

        print(f"[DEBUG] Successfully regenerated project files with real google-adk")

    finally:
        db.close()


def regenerate_project_with_mock_support(project_path, project):
    """
    Regenerate existing project files with mock google.adk support.
    """
    from types import SimpleNamespace
    from models import Agent
    from database import get_db

    print(f"[DEBUG] Regenerating project files for: {project_path}")

    # Create project data object from database project
    project_data = SimpleNamespace()
    project_data.project_name = project.name
    project_data.project_description = project.description
    project_data.supervisor_prompt = project.supervisor_prompt
    project_data.final_response_prompt = project.final_response_prompt
    project_data.platform = project.platform
    project_data.azure_openai_key = project.azure_openai_key
    project_data.azure_openai_url = project.azure_openai_url
    project_data.port_number = project.port_number
    project_data.supervisor_name = "Supervisor"

    # Get all agents for this project
    db = next(get_db())
    try:
        agents = db.query(Agent).filter(Agent.project_id == project.id).all()

        # Regenerate main.py with correct port
        supervisor_name = sanitize_filename(
            getattr(project_data, 'supervisor_name', 'Supervisor'))
        main_code = ADK_MAIN_TEMPLATE.format(
            supervisor_name=supervisor_name,
            port_number=project.port_number
        )
        safe_write(f"{project_path}/main.py", main_code)

        # Regenerate supervisor agent.py
        agent_names = [sanitize_filename(agent.name.lower())
                       for agent in agents]
        agent_list = ', '.join([f"{name}_agent" for name in agent_names])

        # Build import lines for root agent file
        all_import_lines = []
        for name in sorted(agent_names):
            import_line = f"from .subagents.{name} import {name}_agent"
            all_import_lines.append(import_line)

        subagent_import_lines = '\n'.join(
            all_import_lines) if all_import_lines else "# No subagents"

        root_agent_code = ROOT_AGENT_TEMPLATE.format(
            subagent_import_lines=subagent_import_lines,
            agent_list=agent_list,
            model_name="gemini-2.0-flash"
        )

        agent_py_path = f"{project_path}/{supervisor_name}/agent.py"
        safe_write(agent_py_path, root_agent_code)

        # Regenerate subagent files
        for agent in agents:
            agent_name = sanitize_filename(agent.name.lower())
            subagent_base = os.path.join(
                project_path, supervisor_name, "subagents", agent_name)

            # Get final prompt for instruction
            final_prompt_path = os.path.join(
                subagent_base, "prompts", "final_prompt.py")
            try:
                with open(final_prompt_path, "r") as f:
                    instruction = f.read().replace('final_prompt = """', '').replace('"""', '').strip()
            except Exception as e:
                print(
                    f"[WARNING] Could not read final prompt for {agent_name}: {e}")
                instruction = agent.prompt or f"Agent: {agent_name}"

            # Get worker profile for description
            description = getattr(agent, 'worker_profile',
                                  agent.prompt or f"Agent: {agent_name}")

            agent_code = AGENT_TEMPLATE.format(
                agent_name=agent_name,
                model="gemini-2.0-flash",
                description=description,
                instruction=instruction,
                tool_names="",
                imports="",
                tools="[]"
            )
            safe_write(f"{subagent_base}/agent.py", agent_code)

        print(f"[DEBUG] Successfully regenerated project files with mock support")

    finally:
        db.close()


def generate_project_files(project_path, project_data):
    # Install google-adk package before generating files
    print("[INFO] Ensuring google-adk package is installed...")
    install_success = install_google_adk()

    if not install_success:
        print(
            "[WARNING] google-adk installation failed, but continuing with project generation...")

    model_name = "gemini-2.0-flash"
    supervisor_name = sanitize_filename(
        getattr(project_data, 'supervisor_name', 'Supervisor'))

    # Get API key (stored in azure_openai_key field regardless of platform)
    api_key = getattr(project_data, 'azure_openai_key', "")
    platform = getattr(project_data, 'platform', "Azure")
    supervisor_prompt = getattr(project_data, 'supervisor_prompt', "")
    final_response_prompt = getattr(project_data, 'final_response_prompt', "")

    # Create appropriate environment based on platform
    print(f"[DEBUG] Platform detected: '{platform}' (type: {type(platform)})")
    # Get API key from project data (stored in azure_openai_key field)
    api_key = getattr(project_data, 'azure_openai_key', 'your-api-key-here')

    if platform and platform.lower() in ['google', 'gemini', 'vertex', 'google-gemini']:
        print(f"[INFO] Configuring for Google/Gemini platform with API key")
        # Format the template with the API key
        env_code = ENVIRONMENT_TEMPLATE.format(api_key=api_key)
    else:
        print(
            f"[INFO] Configuring for {platform} platform (defaulting to Google-style)")
        # For all platforms, use the Google template with the provided API key
        env_code = ENVIRONMENT_TEMPLATE.format(api_key=api_key)

    config_code = PROJECT_CONFIG_TEMPLATE.format(model_name=model_name)

    safe_write(f"{project_path}/config.py", config_code)
    safe_write(f"{project_path}/.env", env_code)

    # Create requirements.txt with necessary dependencies
    requirements_content = """fastapi==0.104.1
uvicorn==0.24.0
python-dotenv==1.0.0
httpx==0.25.0
pydantic==2.5.0
google-adk==1.14.1
google-generativeai==0.3.2
pandas
pycryptodome
"""
    safe_write(f"{project_path}/requirements.txt", requirements_content)

    # Create a working google.adk module in the project
    create_working_google_adk_module(project_path)

    # Create virtual environment and install dependencies
    print("[INFO] Setting up virtual environment and installing dependencies...")
    venv_success = create_and_setup_venv(project_path)

    if venv_success:
        print("[INFO] Virtual environment setup completed successfully")
    else:
        print("[WARNING] Virtual environment setup failed, but project files are ready")
        print("[INFO] You may need to manually create venv and install dependencies")

    # Create startup scripts
    print("[INFO] Creating startup scripts...")
    create_startup_scripts(project_path)

    # Create README
    print("[INFO] Creating project documentation...")
    create_project_readme(project_path, project_data)

    supervisor_path = os.path.join(project_path, supervisor_name)
    safe_write(f"{supervisor_path}/__init__.py", ROOT_INIT_TEMPLATE)
    os.makedirs(os.path.join(supervisor_path, "subagents"), exist_ok=True)
    safe_write(f"{supervisor_path}/subagents/__init__.py", "")

    prompts_path = os.path.join(supervisor_path, "prompts")
    tools_path = os.path.join(supervisor_path, "tools")
    os.makedirs(prompts_path, exist_ok=True)
    os.makedirs(tools_path, exist_ok=True)

    # SYSTEM INSTRUCTION: User + eval block
    system_instruction_full = ""
    if supervisor_prompt:
        system_instruction_full += supervisor_prompt.strip() + "\n\n"
    system_instruction_full += FINAL_EVAL_CRITERIA

    safe_write(
        f"{prompts_path}/system_instruction.py",
        PROMPT_TEMPLATE.format(agent='system', prompt=system_instruction_full)
    )

    # FINAL RESPONSE INSTRUCTION: user prompt or fallback (no eval block)
    if final_response_prompt:
        safe_write(f"{prompts_path}/final_response_instruction.py",
                   PROMPT_TEMPLATE.format(agent='final_response', prompt=final_response_prompt))
    else:
        safe_write(f"{prompts_path}/final_response_instruction.py",
                   PROMPT_TEMPLATE.format(agent='final_response', prompt="Final response instruction"))


def generate_agent_files(project_path, agent_data):
    """
    Create a subagent folder, prompt file, subagent __init__.py exposing the
    <agent>_agent object, and the agent.py file itself.
    Returns the sanitized agent name (used as folder name).
    """
    agent_name = sanitize_filename(agent_data.agent_name.lower())
    agent_prompt = getattr(agent_data, 'agent_prompt', f"Agent: {agent_name}")
    supervisor_name = sanitize_filename(
        getattr(agent_data, 'supervisor_name', 'Supervisor'))

    # Define supervisor/prompts folder path for agent prompts
    prompts_path = os.path.join(project_path, supervisor_name, "prompts")
    os.makedirs(prompts_path, exist_ok=True)

    # Prepare tools imports (if any)
    if hasattr(agent_data, 'tools_selected') and agent_data.tools_selected:
        _first = agent_data.tools_selected[0]
        use_dict = isinstance(_first, dict)
        if use_dict:
            imports = "\n".join(
                [f"from ...tools.{tool['tool_name']} import {tool['tool_name']}" for tool in agent_data.tools_selected])
            tools = "[" + ", ".join([tool['tool_name']
                                    for tool in agent_data.tools_selected]) + "]"
        else:
            imports = "\n".join(
                [f"from ...tools.{tool} import {tool}" for tool in agent_data.tools_selected])
            tools = "[" + ", ".join(agent_data.tools_selected) + "]"
    else:
        imports = ""
        tools = "[]"

    model_name = "gemini-2.0-flash"

    # Write prompt inside supervisor/prompts folder
    prompt_code = PROMPT_TEMPLATE.format(agent=agent_name, prompt=agent_prompt)
    safe_write(
        f"{prompts_path}/{agent_name}_instruction.py", prompt_code)

    # Create subagent structure (folder named after the agent)
    subagent_base = os.path.join(
        project_path, supervisor_name, "subagents", agent_name)
    os.makedirs(subagent_base, exist_ok=True)

    # Create __init__.py inside each subagent folder that exposes the agent object:
    safe_write(f"{subagent_base}/__init__.py",
               SUBAGENT_INIT_TEMPLATE.format(agent=agent_name))

    # Get final prompt for instruction
    final_prompt_path = os.path.join(
        subagent_base, "prompts", "final_prompt.py")
    try:
        with open(final_prompt_path, "r") as f:
            instruction = f.read().replace('final_prompt = """', '').replace('"""', '').strip()
    except Exception as e:
        print(f"[WARNING] Could not read final prompt for {agent_name}: {e}")
        instruction = agent_prompt

    # Get worker profile for description
    description = getattr(agent_data, 'worker_profile', agent_prompt)

    # Create the actual agent.py for the subagent
    agent_code = AGENT_TEMPLATE.format(
        agent_name=agent_name,
        model=model_name,
        description=description,
        instruction=instruction,
        tool_names="",
        imports=imports,
        tools=tools
    )
    safe_write(f"{subagent_base}/agent.py", agent_code)
    return agent_name


def update_supervisor_and_maintainer(project_path, supervisor_name, agent_names):
    """
    Fill Supervisor/subagents/__init__.py, Supervisor/agent.py, Supervisor/__init__.py as required.
    Generates the root LlmAgent with all subagents imported additively (no overwriting).
    """
    supervisor_name = sanitize_filename(supervisor_name)
    agent_py_path = f"{project_path}/{supervisor_name}/agent.py"

    # Get existing agent names from the current agent.py file if it exists
    existing_agent_names = set()
    existing_imports = []
    existing_agent_list = []

    if os.path.exists(agent_py_path):
        with open(agent_py_path, "r", encoding="utf-8") as f:
            content = f.read()

        # Extract existing imports
        import_lines = []
        for line in content.split('\n'):
            if line.strip().startswith('from .subagents.') and 'import' in line and '_agent' in line:
                import_lines.append(line.strip())
                # Extract agent name from import line
                # e.g., "from .subagents.shop import shop_agent" -> "shop"
                parts = line.split('.')
                if len(parts) >= 3:
                    # Get the part after "subagents."
                    agent_name = parts[2].split()[0]
                    existing_agent_names.add(agent_name)

        existing_imports = import_lines

    # Combine existing and new agent names
    all_agent_names = list(existing_agent_names.union(set(agent_names)))

    # subagents/__init__.py
    if all_agent_names:
        subagents_init_py = SUBAGENTS_INIT_TEMPLATE.format(
            subagent_list=', '.join(sorted(all_agent_names)))
    else:
        subagents_init_py = "# no subagents\n"
    safe_write(
        f"{project_path}/{supervisor_name}/subagents/__init__.py", subagents_init_py)

    # Build import lines for root agent file (combine existing + new)
    all_import_lines = []
    for name in sorted(all_agent_names):
        import_line = f"from .subagents.{name} import {name}_agent"
        all_import_lines.append(import_line)

    subagent_import_lines = "\n".join(all_import_lines)
    sub_agents = ", ".join(
        [f"{name}_agent" for name in sorted(all_agent_names)])

    # Get orchestrator prompt for supervisor instruction
    try:
        with open(os.path.join(project_path, supervisor_name, "prompts", "system_instruction.py"), "r") as f:
            content = f.read()
            # Extract only the supervisor instruction part (before the evaluation criteria)
            if "You are an evaluator" in content:
                instruction = content.split("You are an evaluator")[0]
            else:
                instruction = content
            instruction = instruction.replace(
                'system_instruction = """', '').replace('"""', '').strip()
    except Exception as e:
        print(f"[WARNING] Could not read orchestrator prompt: {e}")
        instruction = "You are a supervisor agent that routes queries to the most appropriate subagent."

    # Format the root agent code with the necessary variables
    root_agent_code = _format_template_safely(
        ROOT_AGENT_TEMPLATE,
        {
            'subagent_import_lines': subagent_import_lines,
            'tool_imports': '# No tools imported',
            'model': "gemini-2.0-flash",
            'instruction': instruction,
            'sub_agents': sub_agents if sub_agents else "",  # Empty string if no sub-agents
            'tools': ''
        },
    )
    safe_write(agent_py_path, root_agent_code)

    # supervisor/__init__.py
    safe_write(f"{project_path}/{supervisor_name}/__init__.py",
               ROOT_INIT_TEMPLATE)

    # main.py entrypoint - Use the port from the project path or default to 8001
    port_number = 8001
    try:
        # Extract project ID from the project path (last part of the path)
        project_id = os.path.basename(os.path.normpath(project_path))

        # Try to get the project from the database
        from database import SessionLocal
        from models import Project

        db = SessionLocal()
        try:
            project = db.query(Project).filter(
                Project.id == project_id).first()
            if project and project.port_number:
                port_number = project.port_number
                print(f"[INFO] Using port {port_number} from database")
            else:
                print(
                    f"[WARNING] Project not found or no port number set, using default port {port_number}")
        except Exception as db_error:
            print(
                f"[WARNING] Database error getting port: {str(db_error)}, using default port {port_number}")
        finally:
            db.close()
    except Exception as e:
        print(
            f"[WARNING] Error getting port: {str(e)}, using default port {port_number}")

    # Format the main.py template with all required variables
    template_vars = {
        'supervisor_name': supervisor_name,
        'port_number': port_number,
        'current_dir': "os.path.dirname(os.path.abspath(__file__))"
    }

    main_code = _format_template_safely(ADK_MAIN_TEMPLATE, template_vars)
    safe_write(f"{project_path}/main.py", main_code)


def generate_tool_files(project_path, tool_data):
    """
    Create a tool file inside supervisor/tools. If it's an MCP tool,
    append SQL env settings into project .env (if provided).
    """
    tool_name = tool_data.tool_name
    tool_type = getattr(tool_data, 'tool_type', "Custom")
    args = getattr(tool_data, 'args', "")
    docstring = getattr(tool_data, 'doc', f"Tool: {tool_name}")

    supervisor_name = sanitize_filename(
        getattr(tool_data, 'supervisor_name', 'Supervisor'))
    tools_path = os.path.join(project_path, supervisor_name, "tools")
    os.makedirs(tools_path, exist_ok=True)

    if tool_type and tool_type.upper() == "MCP":
        tool_code = ADK_MCP_TOOL_TEMPLATE.format(tool=tool_name)
        mcp_server_config = getattr(tool_data, 'mcp_server_config', None)
        if mcp_server_config:
            try:
                env_path = os.path.join(project_path, ".env")
                sql_server = mcp_server_config.get("sql_server", "")
                sql_database = mcp_server_config.get("sql_database", "")
                sql_user = mcp_server_config.get("sql_user", "")
                sql_password = mcp_server_config.get("sql_password", "")
                sql_env = SQL_MCP_ENV_TEMPLATE.format(
                    server=sql_server,
                    database=sql_database,
                    user=sql_user,
                    password=sql_password,
                    driver="{ODBC Driver 18 for SQL Server}"
                )
                with open(env_path, "a", encoding="utf-8") as env_file:
                    env_file.write("\n" + sql_env)
            except Exception as e:
                print(
                    f"Error adding SQL environment variables for {tool_name}: {e}")
    else:
        tool_code = ADK_TOOL_TEMPLATE.format(
            tool=tool_name, args=args, docstring=docstring)

    tool_path = os.path.join(tools_path, f"{tool_name}.py")
    safe_write(tool_path, tool_code)
    return tool_path


def append_to_supervisor_prompt(project_path, new_agent_name: str, supervisor_name: str = "Supervisor"):
    """
    Append a single routing instruction line to supervisor/prompts/system_instruction.py
    Properly handles the triple-quoted string format.
    """
    supervisor_name = sanitize_filename(supervisor_name)
    prompt_path = os.path.join(
        project_path, supervisor_name, "prompts", "system_instruction.py")

    if os.path.exists(prompt_path):
        with open(prompt_path, "r", encoding="utf-8") as f:
            content = f.read()
    else:
        content = ""

    routing_instruction = f"- {new_agent_name}_agent: Handles {new_agent_name.replace('_', ' ')} related tasks"

    # Check if the routing instruction already exists
    if new_agent_name in content:
        print(f"{new_agent_name}_agent already exists in supervisor prompt.")
        return

    # If content exists, we need to insert the routing instruction before the closing triple quotes
    if content.strip():
        # Find the last occurrence of triple quotes
        if '"""' in content:
            # Split at the last triple quotes
            parts = content.rsplit('"""', 1)
            if len(parts) == 2:
                # Look for existing subagents section or create one
                prompt_content = parts[0]

                # Check if there's already a subagents section
                if "Available subagents:" in prompt_content:
                    # Add to existing subagents section
                    new_content = prompt_content + \
                        f"\n{routing_instruction}" + '"""' + parts[1]
                else:
                    # Create new subagents section
                    subagents_section = f"\n\nAvailable subagents:\n{routing_instruction}"
                    new_content = prompt_content + \
                        subagents_section + '"""' + parts[1]
            else:
                # Fallback: just append to the existing content
                new_content = content + f"\n{routing_instruction}"
        else:
            # No triple quotes found, just append
            new_content = content + f"\n{routing_instruction}"
    else:
        # No existing content, create a basic prompt structure
        new_content = f'system_instruction = """Supervisor agent.\n\nAvailable subagents:\n{routing_instruction}"""'

    # Write the updated content
    os.makedirs(os.path.dirname(prompt_path), exist_ok=True)
    with open(prompt_path, "w", encoding="utf-8") as f:
        f.write(new_content)


def remove_from_supervisor_prompt(project_path, agent_name: str, supervisor_name: str = "Supervisor"):
    """
    Remove a routing instruction line from supervisor/prompts/system_instruction.py
    Properly handles the triple-quoted string format.
    """
    supervisor_name = sanitize_filename(supervisor_name)
    prompt_path = os.path.join(
        project_path, supervisor_name, "prompts", "system_instruction.py")

    if not os.path.exists(prompt_path):
        return  # Nothing to remove if file doesn't exist

    with open(prompt_path, "r", encoding="utf-8") as f:
        content = f.read()

    # Check if the agent exists in the content
    if agent_name not in content:
        return  # Nothing to remove

    # Remove the routing instruction line for this agent
    lines = content.split('\n')
    filtered_lines = []

    for line in lines:
        # Skip lines that contain this agent's routing instruction
        if f"{agent_name}_agent:" not in line:
            filtered_lines.append(line)

    # Rejoin the lines
    new_content = '\n'.join(filtered_lines)

    # Clean up any extra blank lines that might have been left
    new_content = re.sub(r'\n\s*\n\s*\n', '\n\n', new_content)

    # Write the updated content
    with open(prompt_path, "w", encoding="utf-8") as f:
        f.write(new_content)


def create_project_with_agents(project_path, project_data, agents_data_list):
    """
    High-level convenience to generate a project with multiple agents.
    """
    generate_project_files(project_path, project_data)
    agent_names = []
    for agent_data in agents_data_list:
        agent_name = generate_agent_files(project_path, agent_data)
        agent_names.append(agent_name)

        supervisor_name = sanitize_filename(
            getattr(agent_data, 'supervisor_name', getattr(project_data, 'supervisor_name', 'Supervisor')))
        append_to_supervisor_prompt(
            project_path, agent_name, supervisor_name=supervisor_name)

    supervisor_name = sanitize_filename(
        getattr(project_data, 'supervisor_name', 'Supervisor'))

    update_supervisor_and_maintainer(
        project_path, supervisor_name, agent_names)


def generate_mcp_aware_agent(project_path: str, agent_name: str, description: str,
                             instruction: str, mcp_url: str = None) -> bool:
    """
    Generate MCP-aware agent files including tools and subagent.

    This function creates a new agent with MCP tooling support. The agent will be configured
    to use MCP tools if an MCP server URL is provided.

    Args:
        project_path: Root path of the project
        agent_name: Name of the agent (will be converted to lowercase for directory names)
        description: Description of the agent's purpose
        instruction: Detailed instructions for the agent
        mcp_url: Optional MCP server URL. If provided, MCP tools will be configured.
                Example: "http://localhost:8000"

    Returns:
        bool: True if generation was successful, False otherwise
    """
    try:
        from pathlib import Path
        import os

        # Create paths
        tools_dir = Path(project_path) / "Supervisor" / "tools"
        agent_dir = Path(project_path) / "Supervisor" / \
            "subagents" / agent_name.lower()

        # Ensure directories exist
        tools_dir.mkdir(parents=True, exist_ok=True)
        agent_dir.mkdir(parents=True, exist_ok=True)

        # Generate tools.py content based on MCP URL
        if mcp_url:
            tools_content = """from google.adk.tools.mcp_tool import MCPToolset, StreamableHTTPConnectionParams
from dotenv import load_dotenv
import os

load_dotenv()
mcp_url = os.getenv("MCP_SERVER_URL", "")

# Define the MCP toolset
mcp_tools = [
    MCPToolset(
        connection_params=StreamableHTTPConnectionParams(
            url=mcp_url
        )
    )
]"""
        else:
            tools_content = "# No MCP tools configured\nmcp_tools = []"

        # Write tools/__init__.py if it doesn't exist
        if not (tools_dir / "__init__.py").exists():
            (tools_dir / "__init__.py").write_text("# Tools package\n")

        # Write tools/tool.py
        (tools_dir / "tool.py").write_text(tools_content)

        # Generate agent.py content based on MCP URL
        if mcp_url:
            agent_content = (
                f'import os\n'
                f'from google.adk.agents import Agent\n'
                f'from typing import Dict, Any\n\n'
                '# Import tools\n'
                f'from ...tools.tool import mcp_tools\n\n'
                f'def create_agent() -> Agent:\n'
                f'    """Create and configure the {agent_name} agent."""\n'
                f'    return Agent(\n'
                f'        name="{agent_name}",\n'
                f'        model="gemini-2.0-flash",\n'
                f'        description="""{description}""",\n'
                f'        instruction="""{instruction}""",\n'
                f'        tools=mcp_tools\n'
                f'    )\n\n'
                '# Create the agent instance\n'
                + f'{agent_name}_agent = create_agent()\n'
            )
        else:
            agent_content = (
                f'import os\n'
                f'from google.adk.agents import Agent\n'
                f'from typing import Dict, Any\n\n'
                f'def create_agent() -> Agent:\n'
                f'    """Create and configure the {agent_name} agent."""\n'
                f'    return Agent(\n'
                f'        name="{agent_name}",\n'
                f'        model="gemini-2.0-flash",\n'
                f'        description="""{description}""",\n'
                f'        instruction="""{instruction}"""\n'
                f'    )\n\n'
                '# Create the agent instance\n'
                + f'{agent_name}_agent = create_agent()\n'
            )

        # Write agent.py
        (agent_dir / "agent.py").write_text(agent_content)

        # Write __init__.py in agent directory
        (agent_dir / "__init__.py").write_text(
            f"from .agent import {agent_name}_agent\n"
        )

        # Update .env with MCP_SERVER_URL if provided
        if mcp_url:
            env_path = Path(project_path) / ".env"
            with open(env_path, "a") as f:
                f.write(
                    f"\n# MCP Server Configuration\nMCP_SERVER_URL={mcp_url}\n")

        print(
            f"[INFO] Generated MCP-aware agent '{agent_name}' with MCP {'enabled' if mcp_url else 'disabled'}")
        return True

    except Exception as e:
        print(f"[ERROR] Failed to generate MCP-aware agent: {str(e)}")
        return False
